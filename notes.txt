This file is here as a mixture of TODOs and implementation thought experiments. Since opportunities to work on the engine are sparse, my thoughts here help me to keep track of what I've been thinking.

Let's call "Bodys" NPCs in this doc.

- Events, particularly paths, ought to be easy to set up.
- Events should be divorced from NPCs (despite their close relationship). This necessitates NPC IDs, almost certainly specified by developer.
- API should allow developer to easily specify an event where NPC moves through a series of positions.
- Since we already have traces in the level editor, it would be cool to be able to make path traces.
    - Path traces ought to be able to bind to positions (one-way or two-way?) so that the engine knows how to handle a call to move from one position to another.
    - Positions ought to be able to bind to multiple paths, but there probably would never be a case to allow two different paths between the same two positions.
- The trace editor could be expanded more.
    - Allow user to move individual points in trace.
    - Allow user to add points to mid-trace?
    - Provide several kinds of traces. (solid, void, path, stair-up, stair-down, function, bounds?)
    - Abstract colors out. (e.g. "function" and "MySpecialEncounter" instead of (100,0,X) since X could easily be set at runtime)
    - Closing a trace should be reconsidered. Currently, a closed trace is filled in, but one might want to close a path.
    - Allow show/hide of traces.
    - Allow user to somehow link path traces to two different positions?
- Traces could be more exposed to the developer.
    - Allow developer to access traces anytime?
    - Let developer define different traces and the behavior of loading them in?
        - Maybe better to abstract out of editor but still leave in engine code.
- Events could be easily set up as a series of waypoint positions
    - Some positions would be linked by paths (e.g. Bob's front door to town entrance) and some not (e.g. Bob's front door to inside)
    - Potentially there could be a third option of runtime straight path between two positions. This would be useful for moving NPCs into a crowd.
    - Arbitrary wait times could be allowed at each position.
    - Arbitrary function execution should be allowed at each position.
    - If player is on the board, NPC walks path.
    - If player is off board, some kind of wait time is calculated and substituted for actually walking the path. How does this work exactly? What should happen if player walks in during the middle of what should be a path event?
    - If play walks off board during walk path, NPC should stop and something like the above point should happen.
    - Maybe calculate remaining time, wait that long, but if player interrupts that time we fast forward to where we should have been walking? The catch-up will probably be expensive, but we are still saving by not walking everyone on every board. Also, load time between boards is probably acceptable.
- Event structure
    - Pieces should only know about the next event to happen.
    - Event chains should not all be queued at initialization.
    - We need to allow joining of event chains (e.g. when both people arrive, do something).
    - Events should be specified entirely independently of NPCs.
- Memory usage
    - Still keep board objects (which load (and reset) on board entrance (N.B. board entrance function can help with some persistence of these)).
    - Need to store positions in memory always.
    - Probably need to store path traces in memory always.
    - Probably shouldn't keep all traces in memory (e.g. solid, void, function traces).
    - Having more links/references around will make for perhaps more complicated data structuring and perhaps more memory usage.
- Save/load considerations
    - If current event is the only thing that is in dynamic memory, we only need to store it on save. This means each piece of chain needs to have an ID so we can later match up the current event to its reconstructed static-memory equivalent.
    - Perhaps have user specify an ID for a chain and then automatically tack on a counter to each piece?
    - What about dynamic events (i.e. events not hard-defined in code, perhaps parameterized based on template and player decisions)? Do they exist? How do we handle them? Maybe still reference a static event but perhaps allow developer to attach a simple parameter object to the event chain which will be saved.

- Other thoughts on save/load
    - Actions should all be preemptible. There are a number of time when actions should just end. They are not meant to be lasting. It is way too complicated to make actions fully serializable especially with their functions and object references.
    - Actions should be terminated upon leaving the board (though not necessarily when switching between subparties).
    - Actions should be terminated upon save because an action's termination may affect the stable state of the game.
    - My classic example of a problematic action is jumping. Jumping cannot just be interrupted and done because that would leave the character on the layer above with no way of getting down.
    - Actions should be able to override a forceEnd function or something like that to have a chance to clean up the mess they made.
    - If the developer really wants to make an action that cannot be interrupted, it is their responsibility to ensure player cannot save the game or leave the board.
    - The paradigm pretty much necessitates that characters are not imbued with new, highly customized (parameterized) actions dynamically during the game but are simply given all their actions at the initialization of the game.
    - Items might provide an opportunity for somewhat more dynamic actions.
    - Actions could have conditions for use based on some character stats or flags.
    - Items should probably be stored in the character object as an array of strings (or some kind of simple object array with quantities).


Positions have
    Board reference
    NPC reference (largely for graphical purposes in editor)
    IDs
        Board
        NPC
        Absolute

Action traces
    - trigger when body enters horizontal area on same layer
    - may or may not run any number of times until body leaves
        
3D

- Sprites should be rendered in order of a topological sort based on comparisons between overlapping sprites rather than in simple y order. (See http://andrewrussell.net/2016/06/how-2-5d-sorting-works-in-river-city-ransom-underground/ and Tarjan's Algorithm)
    - Keep sorted array of visible sprites by horizontal alignment
        - Get data from canvas requirements from sprite
        - Cache data and only update in arrays if changed
        - Array stores two points per sprite: begin and end
        - Comparison algorithm each frame knows it only has to check against other sprites between the two endpoints of each sprite
        - Probably keep separate map into the arrays for quicker access in updating preliminary sort
    - How do I know which of two sprites to draw in front of the other?
        - If they don't overlap horizontally, it doesn't matter
        - Figure out which body is higher
        - //If higher body is also forward body, draw higher second
        - (Generally either higher Y or higher Z will cause the sprite to be rendered second.)
        - (We need one more piece of info--either height or baseY--, in addition to coordinates and canvas size, to properly sort sprites)
        - If lowerBody.y - higherBody.y < higherBody.halfBaseY + lowerBody.halfBaseY, draw higher second
            - (If the distance from lower to higher equals/exceeds the minimum space between as allowed by bases, draw higher first/behind)
            - This method prefers drawing higher Z sprites in conflict
        - Otherwise, draw first (behind) (i.e. when higher sprite is back (Y) sprite and the higher body's and lower body's bases are in the middle)
- A similar method to zeldaBump() will need to be implemented, e.g. zeldaVerticalBump()
    - Rather than using iterative process like horizontal zeldaMove(), try to do the whole thing in one go
    - Think of method like, "What's the furthest this body can go vertically in this direction up to X pixels?"
        - This kind of method limits the base pixel check to 1 time through
    - I guess it still might be iterative like zeldaMove(); the difference is that each step of iteration here would be on a layer rather than 1 horizontal pixel.
    - If falling (typical case):
        - If cached standing on top of other body, check if still standing on that body
        - If still on stood pixel from last frame, end early (common occurrence optimization I think)
        - Otherwise proceed with general case
    - If stopped, set vertical speed to zero (true for upward or downward motion)
        - Not sure if we care about pushing things vertically? That might change the delta vertical speed formula.

- Bodies can have shadows (configurable)
    - Keep extra body in level
    - Each frame reset position to parent body position and then zeldaVerticalDrop arbitrarily large maxDZ

- I need to make sure that rounding for positions is done at appropriate times.
    - Most of the time I want pixel coordinates because that is how all of the physics and rendering (should) work
    - The only reason for having fractional coordinates is for sub-pixel frame movement
    - Maybe create special getters for rounded values?
    
- Change body level calls should be mostly deferred until a dedicated time in game loop rather than happening, say, mid-step
