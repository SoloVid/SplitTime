import { FileData, instanceOfFileData } from "../world/level/level-file-data";
import { Collage, instanceOfCollage } from "../file/collage";
import { Perspective, LoadingScreen, assert } from "../splitTime";
import { ASSETS } from "../G";
import * as G from "../G";
import * as splitTime from "../splitTime";
// Generated by Grunt; not intended for access outside of loading sequence
export var _GAME_DATA: splitTime.CompiledGameData;
export interface CompiledGameData {
    levels: {
        [levelFilePath: string]: FileData;
    };
    collages: {
        [collageFilePath: string]: Collage;
    };
    musicFiles: string[];
    imageFiles: string[];
    preloadedImageFiles: string[];
    soundEffectFiles: string[];
}
export function load(perspective: Perspective): PromiseLike<void> {
    const loadingScreen = new LoadingScreen(perspective.view);
    loadingScreen.show();
    const masterData = G._GAME_DATA;
    let itemsLoaded = 0;
    const promiseCollection: PromiseLike<void>[] = [];
    function incrementAndUpdateLoading() {
        itemsLoaded++;
        loadingScreen.show(Math.round((itemsLoaded / promiseCollection.length) * 100));
    }
    // G.ASSETS = new splitTime.Assets(splitTime.getScriptDirectory(), masterData)
    for (const preloadedImageFileName of masterData.preloadedImageFiles) {
        promiseCollection.push(ASSETS.images
            .load("preloaded/" + preloadedImageFileName, preloadedImageFileName, true)
            .then(incrementAndUpdateLoading));
    }
    for (const musicFileName of masterData.musicFiles) {
        ASSETS.audio.registerMusic(musicFileName);
    }
    for (const soundFxFile of masterData.soundEffectFiles) {
        ASSETS.audio.registerSoundEffect(soundFxFile);
    }
    for (const collageFilePath in masterData.collages) {
        const collageData = masterData.collages[collageFilePath];
        assert(instanceOfCollage(collageData), "\"" + collageFilePath + "\" is an invalid collage");
    }
    for (const levelFilePath in masterData.levels) {
        const levelData = masterData.levels[levelFilePath];
        assert(instanceOfFileData(levelData), "\"" + levelFilePath + "\" is an invalid level");
        var levelName = levelFilePath.replace(/\.json$/, "");
        var level = perspective.world.getLevel(levelName);
        promiseCollection.push(level.load(perspective.world, levelData).then(incrementAndUpdateLoading));
    }
    return Promise.all(promiseCollection).then();
}
